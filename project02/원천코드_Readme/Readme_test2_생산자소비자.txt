프로그램의 개요는 다음과 같다.

메인 프로세스 내에 생산자와 소비자 스레드가 각각 한 개씩 존재하며 이들 스레드는
병행으로 동작하도록 설계되었다.

스레드의 생성과 기능구현은 예제 수준으로 create와 join 정도의 함수밖에 사용하지
않았으며 별도로 언급하지 않았다.

동기화 기능은 pthread_mutex_t 를 활용하여 구현했으며, 생산과 소비를 상호배타적
으로 동작하게 하였다.

또한 생산자 소비자 과정에서 동기화 기능이 적용되지 않았을 경우 race condition
이 발생하는것을 포착하였다. (race condition에 대한 설명은 보고서에서 다시 다룬다.)

프로그램의 동작은 별도의 입력 없이 ./test1 과 ./error1 의
명령어로 동작 가능하다. 

사용되는 변수에 대하여 설명하자면 다음과 같다.
@ work_table : 생산과 소비가 이루어지는 int형 배열이다. => 이후 작업대라고 통칭 
	       (생산된 상태는 1, 소비된상태는 0으로 약속한다)

@ item : 작업대위에 생산된 상품의 수이다. 
	(즉 work_table 배열 내 1의 갯수를 의미함) 

@todo_work: 생산과 소비를 합한 총 작업수를 의미하는 변수이다. 
	    (프로그램은 이 변수에 해당된 만큼의 작업을 수행하면 종료된다)

@TABLE_SIZE: 작업대에 올라갈 수 있는 상품의 총 갯수이다.
	      테스트중 편의를 위해 30으로 고정하였다.
	      (변경시 프로그램이 변경된 크기에 맞추어 동작하도록 설계하였다)

@done_work: 총 실행된 작업의 수이다. 작업이 행해질때마다 증가하도록 설계되었다.
@이하 done_prod / done_cons 또한 실행,소비작업에 따라 증가한다.

마지막으로 배경을 간단하게 요약하자면 다음과 같다.

1.상품을 30개 놓을수 있는 작업대에서 생산자와 소비자가 작업을 하게 된다.

2. 생산자는 작업대가 찰때까지, 소비자는 작업대가 꽉 빌때까지 일을 하게 되어있다. 

3. 생산과 소비를 합쳐서 총 1000번의 작업만 허용한다고 하였을 때 상품의 처리에
   문제가 없는지 관찰한다.
   (이상적으로는 1000 / 2 를 적용하여 총 500개의 상품이 생산되고 소비되어야 한다) 

4. 1000번의 작업을 생산과 소비가 동시에 이루어질 때를 가정하는 error1.c와
   동기화를 적용하여 상호배타적으로 실행되는 test1.c의 결과를 확인하여
   race condition의 발생을 포착한다.
   
